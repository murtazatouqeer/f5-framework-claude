// TDD Test Template for NestJS Service
// Generated by F5 Framework
// Feature: {{FEATURE_NAME}}
// Requirement: {{REQUIREMENT_ID}}
// Date: {{DATE}}

import { Test, TestingModule } from '@nestjs/testing';
import { {{ServiceName}} } from './{{service-file-name}}.service';
{{#each dependencies}}
import { {{name}} } from '{{path}}';
{{/each}}

// ═══════════════════════════════════════════════════════════════
// MOCK FACTORIES
// ═══════════════════════════════════════════════════════════════

{{#each dependencies}}
const createMock{{name}} = () => ({
  {{#each mockMethods}}
  {{name}}: jest.fn(),
  {{/each}}
});
{{/each}}

describe('{{ServiceName}}', () => {
  let service: {{ServiceName}};
  {{#each dependencies}}
  let mock{{name}}: jest.Mocked<{{name}}>;
  {{/each}}

  beforeEach(async () => {
    {{#each dependencies}}
    mock{{name}} = createMock{{name}}() as jest.Mocked<{{name}}>;
    {{/each}}

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        {{ServiceName}},
        {{#each dependencies}}
        { provide: {{name}}, useValue: mock{{name}} },
        {{/each}}
      ],
    }).compile();

    service = module.get<{{ServiceName}}>({{ServiceName}});
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // ═══════════════════════════════════════════════════════════════
  // HAPPY PATH TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Happy Path', () => {
    it('should {{expectedBehavior}} when {{condition}}', async () => {
      // Arrange
      const input = {{testInput}};
      const expected = {{expectedOutput}};
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const result = await service.{{methodName}}(input);

      // Assert
      expect(result).toEqual(expected);
      {{#each assertions}}
      expect({{target}}).{{matcher}}({{value}});
      {{/each}}
    });

    {{#each additionalHappyPathTests}}
    it('should {{description}}', async () => {
      // Arrange
      {{arrange}}

      // Act
      {{act}}

      // Assert
      {{assert}}
    });
    {{/each}}
  });

  // ═══════════════════════════════════════════════════════════════
  // VALIDATION TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Validation', () => {
    {{#each validationTests}}
    it('should reject {{invalidInput}} with {{expectedError}}', async () => {
      // Arrange
      const invalidInput = {{invalidInputValue}};

      // Act & Assert
      await expect(service.{{methodName}}(invalidInput))
        .rejects
        .toThrow({{expectedException}});
    });
    {{/each}}

    it('should reject null input', async () => {
      // Act & Assert
      await expect(service.{{methodName}}(null))
        .rejects
        .toThrow(ValidationException);
    });

    it('should reject undefined input', async () => {
      // Act & Assert
      await expect(service.{{methodName}}(undefined))
        .rejects
        .toThrow(ValidationException);
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // ERROR HANDLING TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Error Handling', () => {
    {{#each errorTests}}
    it('should handle {{errorScenario}}', async () => {
      // Arrange
      const input = {{testInput}};
      mock{{dependency}}.{{method}}.mockRejectedValue(new Error('{{errorMessage}}'));

      // Act & Assert
      await expect(service.{{methodName}}(input))
        .rejects
        .toThrow({{expectedException}});

      {{#if shouldLog}}
      expect(mockLogger.error).toHaveBeenCalledWith(
        expect.stringContaining('{{logMessage}}'),
        expect.any(Object)
      );
      {{/if}}
    });
    {{/each}}

    it('should handle database connection error', async () => {
      // Arrange
      const input = {{testInput}};
      mock{{primaryDependency}}.{{method}}.mockRejectedValue(
        new Error('Database connection failed')
      );

      // Act & Assert
      await expect(service.{{methodName}}(input))
        .rejects
        .toThrow(ServiceException);
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // EDGE CASE TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Edge Cases', () => {
    {{#each edgeCaseTests}}
    it('should handle {{edgeCase}}', async () => {
      // Arrange
      const edgeInput = {{edgeInputValue}};
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const result = await service.{{methodName}}(edgeInput);

      // Assert
      expect(result).{{matcher}}({{expectedValue}});
    });
    {{/each}}

    it('should handle empty input gracefully', async () => {
      // Arrange
      const emptyInput = {};

      // Act & Assert
      await expect(service.{{methodName}}(emptyInput))
        .rejects
        .toThrow(ValidationException);
    });

    it('should handle whitespace-only strings', async () => {
      // Arrange
      const whitespaceInput = { name: '   ', email: '  test@example.com  ' };

      // Act & Assert
      await expect(service.{{methodName}}(whitespaceInput))
        .rejects
        .toThrow(ValidationException);
    });

    it('should handle maximum length input', async () => {
      // Arrange
      const maxLengthInput = {
        name: 'a'.repeat(255),
        email: 'test@example.com'
      };
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const result = await service.{{methodName}}(maxLengthInput);

      // Assert
      expect(result).toBeDefined();
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // SECURITY TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Security', () => {
    it('should not expose sensitive data in response', async () => {
      // Arrange
      const input = {{testInput}};
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const result = await service.{{methodName}}(input);

      // Assert
      expect(result).not.toHaveProperty('password');
      expect(result).not.toHaveProperty('passwordHash');
      expect(result).not.toHaveProperty('secret');
      expect(result).not.toHaveProperty('token');
      expect(JSON.stringify(result)).not.toMatch(/password|secret|token/i);
    });

    it('should sanitize input to prevent injection', async () => {
      // Arrange
      const maliciousInput = {
        name: '<script>alert("xss")</script>',
        email: 'test@example.com'
      };
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const result = await service.{{methodName}}(maliciousInput);

      // Assert
      expect(result.name).not.toContain('<script>');
    });

    {{#each securityTests}}
    it('should {{securityBehavior}}', async () => {
      // Arrange
      {{arrange}}

      // Act
      {{act}}

      // Assert
      {{assert}}
    });
    {{/each}}
  });

  // ═══════════════════════════════════════════════════════════════
  // PERFORMANCE TESTS (Optional)
  // ═══════════════════════════════════════════════════════════════

  describe('{{methodName}} - Performance', () => {
    it('should complete within acceptable time', async () => {
      // Arrange
      const input = {{testInput}};
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const startTime = Date.now();
      await service.{{methodName}}(input);
      const endTime = Date.now();

      // Assert
      expect(endTime - startTime).toBeLessThan(1000); // 1 second
    });

    it('should handle multiple concurrent requests', async () => {
      // Arrange
      const inputs = Array.from({ length: 10 }, (_, i) => ({
        ...{{testInput}},
        id: `test-${i}`
      }));
      {{#each mockSetups}}
      mock{{dependency}}.{{method}}.mockResolvedValue({{returnValue}});
      {{/each}}

      // Act
      const results = await Promise.all(
        inputs.map(input => service.{{methodName}}(input))
      );

      // Assert
      expect(results).toHaveLength(10);
      results.forEach(result => {
        expect(result).toBeDefined();
      });
    });
  });
});
