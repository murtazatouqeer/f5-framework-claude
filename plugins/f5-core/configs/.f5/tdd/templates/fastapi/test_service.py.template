# TDD Test Template for FastAPI Service
# Generated by F5 Framework
# Feature: {{feature_name}}
# Requirement: {{requirement_id}}
# Date: {{date}}

import pytest
from unittest.mock import Mock, patch, AsyncMock, MagicMock
from typing import List, Optional
from datetime import datetime
import asyncio

from fastapi import HTTPException, status
from fastapi.testclient import TestClient
from httpx import AsyncClient
from sqlalchemy.exc import IntegrityError, OperationalError

{{#each imports}}
from {{module}} import {{names}}
{{/each}}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FIXTURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@pytest.fixture
def mock_{{primary_dependency}}():
    """Create mock {{primary_dependency}}."""
    mock = MagicMock()
    {{#each mock_methods}}
    mock.{{name}} = AsyncMock(return_value={{default_return}})
    {{/each}}
    return mock


{{#each dependencies}}
@pytest.fixture
def mock_{{name}}():
    """Create mock {{name}}."""
    mock = MagicMock()
    {{#each methods}}
    mock.{{name}} = AsyncMock(return_value={{default_return}})
    {{/each}}
    return mock

{{/each}}

@pytest.fixture
def service({{dependency_fixtures}}):
    """Create service instance with mocked dependencies."""
    return {{ServiceName}}(
        {{#each dependencies}}
        {{name}}=mock_{{name}},
        {{/each}}
    )


@pytest.fixture
def valid_input():
    """Create valid input data."""
    return {{InputSchema}}(
        {{#each valid_input_fields}}
        {{name}}={{value}},
        {{/each}}
    )


@pytest.fixture
def expected_output():
    """Create expected output data."""
    return {{OutputSchema}}(
        {{#each expected_output_fields}}
        {{name}}={{value}},
        {{/each}}
    )


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HAPPY PATH TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}HappyPath:
    """Happy path tests for {{method_name}}."""

    @pytest.mark.asyncio
    async def test_should_{{expected_behavior}}_when_{{condition}}(
        self,
        service,
        valid_input,
        expected_output,
        {{dependency_fixtures}}
    ):
        """Should {{expected_behavior}} when {{condition}}."""
        # Arrange
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(valid_input)

        # Assert
        assert result == expected_output
        {{#each assertions}}
        mock_{{dependency}}.{{method}}.assert_called_once_with({{args}})
        {{/each}}

    {{#each additional_happy_path_tests}}
    @pytest.mark.asyncio
    async def test_should_{{description}}(
        self,
        service,
        {{fixtures}}
    ):
        """Should {{description}}."""
        # Arrange
        {{arrange}}

        # Act
        {{act}}

        # Assert
        {{assert}}

    {{/each}}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VALIDATION TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}Validation:
    """Validation tests for {{method_name}}."""

    {{#each validation_tests}}
    @pytest.mark.asyncio
    async def test_should_reject_{{invalid_input}}(self, service):
        """Should reject {{invalid_input}}."""
        # Arrange
        invalid_input = {{invalid_input_value}}

        # Act & Assert
        with pytest.raises({{expected_exception}}) as exc_info:
            await service.{{method_name}}(invalid_input)

        assert "{{expected_message}}" in str(exc_info.value)

    {{/each}}

    @pytest.mark.asyncio
    async def test_should_reject_none_input(self, service):
        """Should reject None input."""
        # Act & Assert
        with pytest.raises((ValueError, TypeError)):
            await service.{{method_name}}(None)

    @pytest.mark.asyncio
    async def test_should_reject_empty_input(self, service):
        """Should reject empty input."""
        # Arrange
        empty_input = {{InputSchema}}()

        # Act & Assert
        with pytest.raises(ValueError):
            await service.{{method_name}}(empty_input)

    @pytest.mark.parametrize("invalid_value", ["", "   ", None])
    @pytest.mark.asyncio
    async def test_should_reject_invalid_required_field(
        self,
        service,
        invalid_value
    ):
        """Should reject invalid required field values."""
        # Arrange
        invalid_input = {{InputSchema}}(
            {{required_field}}=invalid_value,
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )

        # Act & Assert
        with pytest.raises(ValueError):
            await service.{{method_name}}(invalid_input)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ERROR HANDLING TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}ErrorHandling:
    """Error handling tests for {{method_name}}."""

    {{#each error_tests}}
    @pytest.mark.asyncio
    async def test_should_handle_{{error_scenario}}(
        self,
        service,
        valid_input,
        mock_{{dependency}}
    ):
        """Should handle {{error_scenario}}."""
        # Arrange
        mock_{{dependency}}.{{method}}.side_effect = {{exception_type}}("{{error_message}}")

        # Act & Assert
        with pytest.raises({{expected_exception}}) as exc_info:
            await service.{{method_name}}(valid_input)

        {{#if has_message}}
        assert "{{expected_message}}" in str(exc_info.value)
        {{/if}}

    {{/each}}

    @pytest.mark.asyncio
    async def test_should_handle_database_connection_error(
        self,
        service,
        valid_input,
        mock_{{primary_dependency}}
    ):
        """Should handle database connection error."""
        # Arrange
        mock_{{primary_dependency}}.{{method}}.side_effect = OperationalError(
            "Connection refused", None, None
        )

        # Act & Assert
        with pytest.raises(HTTPException) as exc_info:
            await service.{{method_name}}(valid_input)

        assert exc_info.value.status_code == status.HTTP_503_SERVICE_UNAVAILABLE

    @pytest.mark.asyncio
    async def test_should_handle_timeout_error(
        self,
        service,
        valid_input,
        mock_{{primary_dependency}}
    ):
        """Should handle timeout error."""
        # Arrange
        mock_{{primary_dependency}}.{{method}}.side_effect = asyncio.TimeoutError()

        # Act & Assert
        with pytest.raises(HTTPException) as exc_info:
            await service.{{method_name}}(valid_input)

        assert exc_info.value.status_code == status.HTTP_504_GATEWAY_TIMEOUT

    @pytest.mark.asyncio
    async def test_should_handle_integrity_error(
        self,
        service,
        valid_input,
        mock_{{primary_dependency}}
    ):
        """Should handle database integrity error."""
        # Arrange
        mock_{{primary_dependency}}.{{method}}.side_effect = IntegrityError(
            "Duplicate key", None, None
        )

        # Act & Assert
        with pytest.raises(HTTPException) as exc_info:
            await service.{{method_name}}(valid_input)

        assert exc_info.value.status_code == status.HTTP_409_CONFLICT


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EDGE CASE TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}EdgeCases:
    """Edge case tests for {{method_name}}."""

    {{#each edge_case_tests}}
    @pytest.mark.asyncio
    async def test_should_handle_{{edge_case}}(
        self,
        service,
        {{fixtures}}
    ):
        """Should handle {{edge_case}}."""
        # Arrange
        edge_input = {{edge_input_value}}
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(edge_input)

        # Assert
        {{assert}}

    {{/each}}

    @pytest.mark.asyncio
    async def test_should_handle_maximum_length_input(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should handle maximum length input."""
        # Arrange
        max_length_input = {{InputSchema}}(
            name="a" * 255,
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(max_length_input)

        # Assert
        assert result is not None

    @pytest.mark.asyncio
    async def test_should_handle_special_characters(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should handle special characters in input."""
        # Arrange
        special_input = {{InputSchema}}(
            name="Test'\"<>&ç‰¹æ®Šæ–‡å­—",
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(special_input)

        # Assert
        assert result is not None

    @pytest.mark.asyncio
    async def test_should_handle_empty_collection_result(
        self,
        service,
        mock_{{primary_dependency}}
    ):
        """Should handle empty collection result."""
        # Arrange
        mock_{{primary_dependency}}.{{method}}.return_value = []

        # Act
        result = await service.find_all()

        # Assert
        assert result == []

    @pytest.mark.asyncio
    async def test_should_handle_unicode_input(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should handle unicode input correctly."""
        # Arrange
        unicode_input = {{InputSchema}}(
            name="æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ ğŸš€ Ã©mojis",
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(unicode_input)

        # Assert
        assert result is not None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECURITY TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}Security:
    """Security tests for {{method_name}}."""

    @pytest.mark.asyncio
    async def test_should_not_expose_sensitive_data(
        self,
        service,
        valid_input,
        {{dependency_fixtures}}
    ):
        """Should not expose sensitive data in response."""
        # Arrange
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(valid_input)

        # Assert
        result_dict = result.dict() if hasattr(result, 'dict') else vars(result)
        result_str = str(result_dict).lower()

        assert "password" not in result_str
        assert "secret" not in result_str
        assert "token" not in result_str

    @pytest.mark.asyncio
    async def test_should_sanitize_xss_input(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should sanitize XSS attack input."""
        # Arrange
        malicious_input = {{InputSchema}}(
            name="<script>alert('xss')</script>",
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(malicious_input)

        # Assert
        assert "<script>" not in str(result)

    @pytest.mark.asyncio
    async def test_should_prevent_sql_injection(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should prevent SQL injection attacks."""
        # Arrange
        malicious_input = {{InputSchema}}(
            name="'; DROP TABLE users; --",
            {{#each other_valid_fields}}
            {{name}}={{value}},
            {{/each}}
        )
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        result = await service.{{method_name}}(malicious_input)

        # Assert - Should either sanitize or reject
        # The important thing is no SQL injection executed
        if result:
            assert "DROP TABLE" not in str(result)

    {{#each security_tests}}
    @pytest.mark.asyncio
    async def test_should_{{security_behavior}}(
        self,
        service,
        {{fixtures}}
    ):
        """Should {{security_behavior}}."""
        # Arrange
        {{arrange}}

        # Act
        {{act}}

        # Assert
        {{assert}}

    {{/each}}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PERFORMANCE TESTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Test{{MethodNamePascal}}Performance:
    """Performance tests for {{method_name}}."""

    @pytest.mark.asyncio
    async def test_should_complete_within_acceptable_time(
        self,
        service,
        valid_input,
        {{dependency_fixtures}}
    ):
        """Should complete within acceptable time."""
        import time

        # Arrange
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        # Act
        start_time = time.time()
        await service.{{method_name}}(valid_input)
        end_time = time.time()

        # Assert
        assert (end_time - start_time) < 1.0  # 1 second

    @pytest.mark.asyncio
    async def test_should_handle_concurrent_requests(
        self,
        service,
        {{dependency_fixtures}}
    ):
        """Should handle multiple concurrent requests."""
        # Arrange
        request_count = 10
        {{#each mock_setups}}
        mock_{{dependency}}.{{method}}.return_value = {{return_value}}
        {{/each}}

        async def make_request(id: int):
            input_data = {{InputSchema}}(
                id=f"test-{id}",
                {{#each other_valid_fields}}
                {{name}}={{value}},
                {{/each}}
            )
            return await service.{{method_name}}(input_data)

        # Act
        tasks = [make_request(i) for i in range(request_count)]
        results = await asyncio.gather(*tasks)

        # Assert
        assert len(results) == request_count
        assert all(result is not None for result in results)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTEGRATION TESTS (Optional - with real dependencies)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@pytest.mark.integration
class Test{{MethodNamePascal}}Integration:
    """Integration tests for {{method_name}} with real dependencies."""

    @pytest.fixture
    def real_service(self, db_session):
        """Create service with real database session."""
        return {{ServiceName}}(
            {{#each dependencies}}
            {{name}}={{RealImplementation}}(db_session),
            {{/each}}
        )

    @pytest.mark.asyncio
    async def test_full_workflow(self, real_service, db_session):
        """Test full workflow with real dependencies."""
        # This test requires a real database connection
        # Skip if not configured
        pytest.skip("Integration test - requires database")

        # Arrange
        input_data = {{InputSchema}}(
            {{#each valid_input_fields}}
            {{name}}={{value}},
            {{/each}}
        )

        # Act
        result = await real_service.{{method_name}}(input_data)

        # Assert
        assert result is not None
        # Add specific assertions based on expected database state


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_valid_input(**overrides):
    """Helper to create valid input with optional overrides."""
    defaults = {
        {{#each valid_input_fields}}
        "{{name}}": {{value}},
        {{/each}}
    }
    defaults.update(overrides)
    return {{InputSchema}}(**defaults)


def create_mock_output(**overrides):
    """Helper to create mock output with optional overrides."""
    defaults = {
        {{#each expected_output_fields}}
        "{{name}}": {{value}},
        {{/each}}
    }
    defaults.update(overrides)
    return {{OutputSchema}}(**defaults)
