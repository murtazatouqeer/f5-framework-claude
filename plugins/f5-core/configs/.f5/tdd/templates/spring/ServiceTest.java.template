// TDD Test Template for Spring Service
// Generated by F5 Framework
// Feature: {{FeatureName}}
// Requirement: {{RequirementID}}
// Date: {{Date}}

package {{package}};

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.BDDMockito.*;
import static org.mockito.Mockito.*;

{{#each imports}}
import {{path}};
{{/each}}

// ═══════════════════════════════════════════════════════════════
// TEST CLASS
// ═══════════════════════════════════════════════════════════════

@ExtendWith(MockitoExtension.class)
@DisplayName("{{ServiceName}} Tests")
class {{ServiceName}}Test {

    @InjectMocks
    private {{ServiceName}} service;

    {{#each dependencies}}
    @Mock
    private {{type}} {{name}};
    {{/each}}

    private AutoCloseable mocks;

    @BeforeEach
    void setUp() {
        mocks = MockitoAnnotations.openMocks(this);
        {{#each setupStatements}}
        {{statement}}
        {{/each}}
    }

    @AfterEach
    void tearDown() throws Exception {
        mocks.close();
    }

    // ═══════════════════════════════════════════════════════════════
    // HAPPY PATH TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Happy Path")
    class HappyPath {

        @Test
        @DisplayName("should {{expectedBehavior}} when {{condition}}")
        void should{{ExpectedBehaviorPascal}}_when{{ConditionPascal}}() {
            // Arrange
            {{InputType}} input = {{testInput}};
            {{OutputType}} expected = {{expectedOutput}};

            {{#each mockSetups}}
            given({{dependency}}.{{method}}({{args}}))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(input);

            // Assert
            assertThat(result).isEqualTo(expected);
            {{#each verifications}}
            verify({{dependency}}).{{method}}({{args}});
            {{/each}}
        }

        {{#each additionalHappyPathTests}}
        @Test
        @DisplayName("should {{description}}")
        void should{{DescriptionPascal}}() {
            // Arrange
            {{arrange}}

            // Act
            {{act}}

            // Assert
            {{assert}}
        }
        {{/each}}
    }

    // ═══════════════════════════════════════════════════════════════
    // VALIDATION TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Validation")
    class Validation {

        {{#each validationTests}}
        @Test
        @DisplayName("should reject {{invalidInput}}")
        void shouldReject{{InvalidInputPascal}}() {
            // Arrange
            {{InputType}} invalidInput = {{invalidInputValue}};

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(invalidInput))
                .isInstanceOf({{expectedException}}.class)
                .hasMessageContaining("{{expectedMessage}}");
        }
        {{/each}}

        @Test
        @DisplayName("should reject null input")
        void shouldRejectNullInput() {
            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(null))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("must not be null");
        }

        @ParameterizedTest
        @NullAndEmptySource
        @DisplayName("should reject null and empty strings")
        void shouldRejectNullAndEmptyStrings(String value) {
            // Arrange
            {{InputType}} input = {{InputType}}.builder()
                .name(value)
                .build();

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(input))
                .isInstanceOf(ValidationException.class);
        }

        @ParameterizedTest
        @ValueSource(strings = {"", "   ", "\t", "\n"})
        @DisplayName("should reject blank strings")
        void shouldRejectBlankStrings(String value) {
            // Arrange
            {{InputType}} input = {{InputType}}.builder()
                .name(value)
                .build();

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(input))
                .isInstanceOf(ValidationException.class);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // ERROR HANDLING TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Error Handling")
    class ErrorHandling {

        {{#each errorTests}}
        @Test
        @DisplayName("should handle {{errorScenario}}")
        void shouldHandle{{ErrorScenarioPascal}}() {
            // Arrange
            {{InputType}} input = {{testInput}};

            given({{dependency}}.{{method}}({{args}}))
                .willThrow(new {{exceptionType}}("{{errorMessage}}"));

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(input))
                .isInstanceOf({{expectedException}}.class)
                {{#if hasMessage}}
                .hasMessageContaining("{{expectedMessage}}")
                {{/if}}
                {{#if hasCause}}
                .hasCauseInstanceOf({{exceptionType}}.class)
                {{/if}};

            {{#if shouldLog}}
            // Verify logging
            // Use appropriate logging verification
            {{/if}}
        }
        {{/each}}

        @Test
        @DisplayName("should handle database connection error")
        void shouldHandleDatabaseConnectionError() {
            // Arrange
            {{InputType}} input = {{testInput}};

            given({{primaryDependency}}.{{method}}(any()))
                .willThrow(new DataAccessException("Connection refused") {});

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(input))
                .isInstanceOf(ServiceException.class)
                .hasMessageContaining("database");
        }

        @Test
        @DisplayName("should handle timeout exception")
        void shouldHandleTimeoutException() {
            // Arrange
            {{InputType}} input = {{testInput}};

            given({{primaryDependency}}.{{method}}(any()))
                .willThrow(new TimeoutException("Operation timed out"));

            // Act & Assert
            assertThatThrownBy(() -> service.{{methodName}}(input))
                .isInstanceOf(ServiceException.class);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // EDGE CASE TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Edge Cases")
    class EdgeCases {

        {{#each edgeCaseTests}}
        @Test
        @DisplayName("should handle {{edgeCase}}")
        void shouldHandle{{EdgeCasePascal}}() {
            // Arrange
            {{InputType}} edgeInput = {{edgeInputValue}};

            {{#each mockSetups}}
            given({{dependency}}.{{method}}({{args}}))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(edgeInput);

            // Assert
            {{assert}}
        }
        {{/each}}

        @Test
        @DisplayName("should handle maximum length input")
        void shouldHandleMaximumLengthInput() {
            // Arrange
            String maxLengthName = "a".repeat(255);
            {{InputType}} input = {{InputType}}.builder()
                .name(maxLengthName)
                .build();

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(input);

            // Assert
            assertThat(result).isNotNull();
        }

        @Test
        @DisplayName("should handle special characters")
        void shouldHandleSpecialCharacters() {
            // Arrange
            {{InputType}} input = {{InputType}}.builder()
                .name("Test'\"<>&特殊文字")
                .build();

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(input);

            // Assert
            assertThat(result).isNotNull();
        }

        @Test
        @DisplayName("should handle empty collection")
        void shouldHandleEmptyCollection() {
            // Arrange
            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn(Collections.emptyList());
            {{/each}}

            // Act
            List<{{OutputType}}> result = service.findAll();

            // Assert
            assertThat(result).isEmpty();
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // SECURITY TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Security")
    class Security {

        @Test
        @DisplayName("should not expose sensitive data in response")
        void shouldNotExposeSensitiveDataInResponse() {
            // Arrange
            {{InputType}} input = {{testInput}};

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(input);

            // Assert
            String resultString = result.toString();
            assertThat(resultString).doesNotContainIgnoringCase("password");
            assertThat(resultString).doesNotContainIgnoringCase("secret");
            assertThat(resultString).doesNotContainIgnoringCase("token");
        }

        @Test
        @DisplayName("should sanitize input to prevent injection")
        void shouldSanitizeInputToPreventInjection() {
            // Arrange
            {{InputType}} maliciousInput = {{InputType}}.builder()
                .name("<script>alert('xss')</script>")
                .description("'; DROP TABLE users; --")
                .build();

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            {{OutputType}} result = service.{{methodName}}(maliciousInput);

            // Assert
            assertThat(result.getName()).doesNotContain("<script>");
            assertThat(result.getDescription()).doesNotContain("DROP TABLE");
        }

        {{#each securityTests}}
        @Test
        @DisplayName("should {{securityBehavior}}")
        void should{{SecurityBehaviorPascal}}() {
            // Arrange
            {{arrange}}

            // Act
            {{act}}

            // Assert
            {{assert}}
        }
        {{/each}}
    }

    // ═══════════════════════════════════════════════════════════════
    // CONCURRENCY TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Concurrency")
    class Concurrency {

        @Test
        @DisplayName("should be thread-safe for concurrent access")
        void shouldBeThreadSafeForConcurrentAccess() throws Exception {
            // Arrange
            int threadCount = 10;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch latch = new CountDownLatch(threadCount);
            List<Future<{{OutputType}}>> futures = new ArrayList<>();

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            for (int i = 0; i < threadCount; i++) {
                final int id = i;
                futures.add(executor.submit(() -> {
                    try {
                        {{InputType}} input = {{InputType}}.builder()
                            .id("test-" + id)
                            .build();
                        return service.{{methodName}}(input);
                    } finally {
                        latch.countDown();
                    }
                }));
            }

            latch.await(30, TimeUnit.SECONDS);
            executor.shutdown();

            // Assert
            List<{{OutputType}}> results = new ArrayList<>();
            for (Future<{{OutputType}}> future : futures) {
                assertThat(future.get()).isNotNull();
                results.add(future.get());
            }
            assertThat(results).hasSize(threadCount);
        }

        @Test
        @DisplayName("should handle race conditions gracefully")
        void shouldHandleRaceConditionsGracefully() throws Exception {
            // Arrange
            int iterations = 100;

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act - Rapid sequential calls
            List<{{OutputType}}> results = new ArrayList<>();
            for (int i = 0; i < iterations; i++) {
                {{InputType}} input = {{InputType}}.builder()
                    .id("test-" + i)
                    .build();
                results.add(service.{{methodName}}(input));
            }

            // Assert
            assertThat(results).hasSize(iterations);
            assertThat(results).allMatch(Objects::nonNull);
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // PERFORMANCE TESTS
    // ═══════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("{{MethodName}} - Performance")
    class Performance {

        @Test
        @DisplayName("should complete within acceptable time")
        void shouldCompleteWithinAcceptableTime() {
            // Arrange
            {{InputType}} input = {{testInput}};

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            long startTime = System.currentTimeMillis();
            service.{{methodName}}(input);
            long endTime = System.currentTimeMillis();

            // Assert
            assertThat(endTime - startTime).isLessThan(1000); // 1 second
        }

        @Test
        @DisplayName("should handle multiple concurrent requests efficiently")
        void shouldHandleMultipleConcurrentRequestsEfficiently() throws Exception {
            // Arrange
            int requestCount = 10;
            ExecutorService executor = Executors.newFixedThreadPool(requestCount);

            {{#each mockSetups}}
            given({{dependency}}.{{method}}(any()))
                .willReturn({{returnValue}});
            {{/each}}

            // Act
            long startTime = System.currentTimeMillis();
            List<Future<{{OutputType}}>> futures = IntStream.range(0, requestCount)
                .mapToObj(i -> executor.submit(() -> {
                    {{InputType}} input = {{InputType}}.builder()
                        .id("perf-test-" + i)
                        .build();
                    return service.{{methodName}}(input);
                }))
                .collect(Collectors.toList());

            for (Future<{{OutputType}}> future : futures) {
                future.get(30, TimeUnit.SECONDS);
            }
            long endTime = System.currentTimeMillis();

            executor.shutdown();

            // Assert - All should complete in reasonable time
            assertThat(endTime - startTime).isLessThan(5000); // 5 seconds for all
        }
    }

    // ═══════════════════════════════════════════════════════════════
    // HELPER METHODS
    // ═══════════════════════════════════════════════════════════════

    private {{InputType}} createValidInput() {
        return {{InputType}}.builder()
            {{#each validInputFields}}
            .{{name}}({{value}})
            {{/each}}
            .build();
    }

    private {{OutputType}} createExpectedOutput() {
        return {{OutputType}}.builder()
            {{#each expectedOutputFields}}
            .{{name}}({{value}})
            {{/each}}
            .build();
    }
}
