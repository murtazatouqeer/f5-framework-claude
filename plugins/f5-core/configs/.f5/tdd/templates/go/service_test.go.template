// TDD Test Template for Go Service
// Generated by F5 Framework
// Feature: {{FeatureName}}
// Requirement: {{RequirementID}}
// Date: {{Date}}

package {{package}}

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// ═══════════════════════════════════════════════════════════════
// MOCKS
// ═══════════════════════════════════════════════════════════════

{{#each dependencies}}
// Mock{{Name}} is a mock implementation of {{Name}}
type Mock{{Name}} struct {
	mock.Mock
}

{{#each methods}}
func (m *Mock{{../Name}}) {{Name}}({{params}}) {{returnType}} {
	args := m.Called({{argNames}})
	{{#if hasMultipleReturns}}
	return args.Get(0).({{returnType1}}), args.Error(1)
	{{else if hasReturn}}
	return args.Get(0).({{returnType}})
	{{else}}
	return args.Error(0)
	{{/if}}
}
{{/each}}
{{/each}}

// ═══════════════════════════════════════════════════════════════
// TEST SETUP
// ═══════════════════════════════════════════════════════════════

type testSuite struct {
	service *{{ServiceName}}
	{{#each dependencies}}
	mock{{Name}} *Mock{{Name}}
	{{/each}}
	ctx context.Context
}

func setupTest(t *testing.T) *testSuite {
	t.Helper()

	suite := &testSuite{
		ctx: context.Background(),
		{{#each dependencies}}
		mock{{Name}}: new(Mock{{Name}}),
		{{/each}}
	}

	suite.service = New{{ServiceName}}(
		{{#each dependencies}}
		suite.mock{{Name}},
		{{/each}}
	)

	return suite
}

func (s *testSuite) assertExpectations(t *testing.T) {
	t.Helper()
	{{#each dependencies}}
	s.mock{{Name}}.AssertExpectations(t)
	{{/each}}
}

// ═══════════════════════════════════════════════════════════════
// HAPPY PATH TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_HappyPath(t *testing.T) {
	t.Run("should {{expectedBehavior}} when {{condition}}", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		input := {{testInput}}
		expected := {{expectedOutput}}

		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", {{args}}).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, input)

		// Assert
		require.NoError(t, err)
		assert.Equal(t, expected, result)
		{{#each assertions}}
		suite.mock{{dependency}}.AssertCalled(t, "{{method}}", {{args}})
		{{/each}}
		suite.assertExpectations(t)
	})

	{{#each additionalHappyPathTests}}
	t.Run("should {{description}}", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		{{arrange}}

		// Act
		{{act}}

		// Assert
		{{assert}}
		suite.assertExpectations(t)
	})
	{{/each}}
}

// ═══════════════════════════════════════════════════════════════
// VALIDATION TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_Validation(t *testing.T) {
	{{#each validationTests}}
	t.Run("should reject {{invalidInput}}", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		invalidInput := {{invalidInputValue}}

		// Act
		_, err := suite.service.{{MethodName}}(suite.ctx, invalidInput)

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, {{expectedError}})
	})
	{{/each}}

	t.Run("should reject nil input", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)

		// Act
		_, err := suite.service.{{MethodName}}(suite.ctx, nil)

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, ErrInvalidInput)
	})

	t.Run("should reject empty input", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		emptyInput := &{{InputType}}{}

		// Act
		_, err := suite.service.{{MethodName}}(suite.ctx, emptyInput)

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, ErrInvalidInput)
	})
}

// ═══════════════════════════════════════════════════════════════
// ERROR HANDLING TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_ErrorHandling(t *testing.T) {
	{{#each errorTests}}
	t.Run("should handle {{errorScenario}}", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		input := {{testInput}}
		expectedErr := errors.New("{{errorMessage}}")

		suite.mock{{dependency}}.On("{{method}}", {{args}}).Return({{zeroValue}}, expectedErr)

		// Act
		_, err := suite.service.{{MethodName}}(suite.ctx, input)

		// Assert
		require.Error(t, err)
		{{#if wrapError}}
		assert.ErrorIs(t, err, {{wrappedError}})
		{{else}}
		assert.Contains(t, err.Error(), "{{errorMessage}}")
		{{/if}}
		suite.assertExpectations(t)
	})
	{{/each}}

	t.Run("should handle context cancellation", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		ctx, cancel := context.WithCancel(suite.ctx)
		cancel() // Cancel immediately

		// Act
		_, err := suite.service.{{MethodName}}(ctx, {{testInput}})

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, context.Canceled)
	})

	t.Run("should handle context timeout", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		ctx, cancel := context.WithTimeout(suite.ctx, 1*time.Nanosecond)
		defer cancel()
		time.Sleep(2 * time.Nanosecond)

		// Act
		_, err := suite.service.{{MethodName}}(ctx, {{testInput}})

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, context.DeadlineExceeded)
	})

	t.Run("should handle database connection error", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		input := {{testInput}}

		suite.mock{{primaryDependency}}.On("{{method}}", mock.Anything).
			Return({{zeroValue}}, errors.New("connection refused"))

		// Act
		_, err := suite.service.{{MethodName}}(suite.ctx, input)

		// Assert
		require.Error(t, err)
		assert.ErrorIs(t, err, ErrDatabaseError)
		suite.assertExpectations(t)
	})
}

// ═══════════════════════════════════════════════════════════════
// EDGE CASE TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_EdgeCases(t *testing.T) {
	{{#each edgeCaseTests}}
	t.Run("should handle {{edgeCase}}", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		edgeInput := {{edgeInputValue}}
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", {{args}}).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, edgeInput)

		// Assert
		{{assert}}
		suite.assertExpectations(t)
	})
	{{/each}}

	t.Run("should handle maximum length input", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		maxLengthInput := {{maxLengthInput}}
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, maxLengthInput)

		// Assert
		require.NoError(t, err)
		assert.NotNil(t, result)
		suite.assertExpectations(t)
	})

	t.Run("should handle special characters", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		specialInput := &{{InputType}}{
			Name: "Test'\"<>&",
		}
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, specialInput)

		// Assert
		require.NoError(t, err)
		assert.NotNil(t, result)
		suite.assertExpectations(t)
	})
}

// ═══════════════════════════════════════════════════════════════
// CONCURRENCY TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_Concurrency(t *testing.T) {
	t.Run("should be safe for concurrent use", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
		{{/each}}

		// Act - Run concurrently
		const goroutines = 10
		errChan := make(chan error, goroutines)
		resultChan := make(chan {{ResultType}}, goroutines)

		for i := 0; i < goroutines; i++ {
			go func(id int) {
				input := &{{InputType}}{
					ID: fmt.Sprintf("test-%d", id),
				}
				result, err := suite.service.{{MethodName}}(suite.ctx, input)
				errChan <- err
				if result != nil {
					resultChan <- *result
				}
			}(i)
		}

		// Assert - All should succeed
		for i := 0; i < goroutines; i++ {
			err := <-errChan
			assert.NoError(t, err)
		}
		close(resultChan)

		results := make([]{{ResultType}}, 0, goroutines)
		for result := range resultChan {
			results = append(results, result)
		}
		assert.Len(t, results, goroutines)
	})

	t.Run("should handle race conditions", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil).Maybe()
		{{/each}}

		// Act - Rapid sequential calls
		for i := 0; i < 100; i++ {
			input := &{{InputType}}{ID: fmt.Sprintf("test-%d", i)}
			_, _ = suite.service.{{MethodName}}(suite.ctx, input)
		}

		// No race condition detected by -race flag
	})
}

// ═══════════════════════════════════════════════════════════════
// SECURITY TESTS
// ═══════════════════════════════════════════════════════════════

func Test{{MethodName}}_Security(t *testing.T) {
	t.Run("should not expose sensitive data in response", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		input := {{testInput}}
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, input)

		// Assert
		require.NoError(t, err)
		assert.Empty(t, result.Password)
		assert.Empty(t, result.Secret)
		assert.NotContains(t, fmt.Sprintf("%+v", result), "password")
		suite.assertExpectations(t)
	})

	t.Run("should sanitize input", func(t *testing.T) {
		// Arrange
		suite := setupTest(t)
		maliciousInput := &{{InputType}}{
			Name: "<script>alert('xss')</script>",
		}
		{{#each mockSetups}}
		suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
		{{/each}}

		// Act
		result, err := suite.service.{{MethodName}}(suite.ctx, maliciousInput)

		// Assert
		require.NoError(t, err)
		assert.NotContains(t, result.Name, "<script>")
		suite.assertExpectations(t)
	})
}

// ═══════════════════════════════════════════════════════════════
// BENCHMARK TESTS
// ═══════════════════════════════════════════════════════════════

func Benchmark{{MethodName}}(b *testing.B) {
	suite := &testSuite{
		ctx: context.Background(),
		{{#each dependencies}}
		mock{{Name}}: new(Mock{{Name}}),
		{{/each}}
	}

	suite.service = New{{ServiceName}}(
		{{#each dependencies}}
		suite.mock{{Name}},
		{{/each}}
	)

	{{#each mockSetups}}
	suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
	{{/each}}

	input := {{benchmarkInput}}

	b.ResetTimer()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		_, _ = suite.service.{{MethodName}}(suite.ctx, input)
	}
}

func Benchmark{{MethodName}}_Parallel(b *testing.B) {
	suite := &testSuite{
		ctx: context.Background(),
		{{#each dependencies}}
		mock{{Name}}: new(Mock{{Name}}),
		{{/each}}
	}

	suite.service = New{{ServiceName}}(
		{{#each dependencies}}
		suite.mock{{Name}},
		{{/each}}
	)

	{{#each mockSetups}}
	suite.mock{{dependency}}.On("{{method}}", mock.Anything).Return({{returnValue}}, nil)
	{{/each}}

	input := {{benchmarkInput}}

	b.ResetTimer()
	b.ReportAllocs()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, _ = suite.service.{{MethodName}}(suite.ctx, input)
		}
	})
}
