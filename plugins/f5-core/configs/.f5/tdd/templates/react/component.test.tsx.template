// TDD Test Template for React Component
// Generated by F5 Framework
// Component: {{ComponentName}}
// Requirement: {{REQUIREMENT_ID}}
// Date: {{DATE}}

import React from 'react';
import { render, screen, fireEvent, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { {{ComponentName}} } from './{{ComponentName}}';
import type { {{ComponentName}}Props } from './{{ComponentName}}.types';
{{#each imports}}
import { {{name}} } from '{{path}}';
{{/each}}

// ═══════════════════════════════════════════════════════════════
// MOCK SETUP
// ═══════════════════════════════════════════════════════════════

{{#each mocks}}
jest.mock('{{path}}', () => ({
  {{#each exports}}
  {{name}}: jest.fn({{defaultImplementation}}),
  {{/each}}
}));
{{/each}}

describe('{{ComponentName}}', () => {
  // Default props
  const defaultProps: {{ComponentName}}Props = {
    {{#each defaultProps}}
    {{name}}: {{value}},
    {{/each}}
  };

  // Helper function to render component
  const renderComponent = (props: Partial<{{ComponentName}}Props> = {}) => {
    const mergedProps = { ...defaultProps, ...props };
    return render(
      {{#if wrapper}}
      <{{wrapper}}>
        <{{ComponentName}} {...mergedProps} />
      </{{wrapper}}>
      {{else}}
      <{{ComponentName}} {...mergedProps} />
      {{/if}}
    );
  };

  // Setup user event
  const user = userEvent.setup();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ═══════════════════════════════════════════════════════════════
  // RENDERING TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('Rendering', () => {
    it('should render without crashing', () => {
      renderComponent();
      expect(screen.getByTestId('{{component-test-id}}')).toBeInTheDocument();
    });

    it('should render with default props', () => {
      renderComponent();
      {{#each defaultRenderAssertions}}
      expect(screen.{{queryMethod}}('{{selector}}')).{{matcher}}();
      {{/each}}
    });

    it('should render children correctly', () => {
      const children = <span data-testid="child">Child Content</span>;
      renderComponent({ children });
      expect(screen.getByTestId('child')).toBeInTheDocument();
      expect(screen.getByText('Child Content')).toBeInTheDocument();
    });

    {{#each conditionalRenderTests}}
    it('should render {{element}} when {{condition}}', () => {
      renderComponent({ {{prop}}: {{value}} });
      expect(screen.{{queryMethod}}('{{selector}}')).{{matcher}}();
    });
    {{/each}}

    it('should apply custom className', () => {
      renderComponent({ className: 'custom-class' });
      expect(screen.getByTestId('{{component-test-id}}')).toHaveClass('custom-class');
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // INTERACTION TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('Interactions', () => {
    {{#each interactionTests}}
    it('should {{expectedBehavior}} when {{userAction}}', async () => {
      {{#if mockSetup}}
      {{mockSetup}}
      {{/if}}

      renderComponent({{props}});

      // Act
      {{#each actions}}
      await user.{{action}}(screen.{{queryMethod}}('{{selector}}'));
      {{/each}}

      // Assert
      {{#each assertions}}
      {{#if async}}
      await waitFor(() => {
        expect({{target}}).{{matcher}}({{value}});
      });
      {{else}}
      expect({{target}}).{{matcher}}({{value}});
      {{/if}}
      {{/each}}
    });
    {{/each}}

    it('should call onClick handler when clicked', async () => {
      const onClick = jest.fn();
      renderComponent({ onClick });

      await user.click(screen.getByTestId('{{component-test-id}}'));

      expect(onClick).toHaveBeenCalledTimes(1);
    });

    it('should handle form submission', async () => {
      const onSubmit = jest.fn();
      renderComponent({ onSubmit });

      // Fill form
      {{#each formFields}}
      await user.type(screen.getByLabelText('{{label}}'), '{{value}}');
      {{/each}}

      // Submit
      await user.click(screen.getByRole('button', { name: /submit/i }));

      // Assert
      await waitFor(() => {
        expect(onSubmit).toHaveBeenCalledWith(
          expect.objectContaining({
            {{#each expectedFormData}}
            {{field}}: '{{value}}',
            {{/each}}
          })
        );
      });
    });

    it('should prevent double submission', async () => {
      const onSubmit = jest.fn();
      renderComponent({ onSubmit });

      const submitButton = screen.getByRole('button', { name: /submit/i });

      // Double click rapidly
      await user.dblClick(submitButton);

      // Should only be called once
      expect(onSubmit).toHaveBeenCalledTimes(1);
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // STATE TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('State Management', () => {
    {{#each stateTests}}
    it('should {{expectedBehavior}} when state changes', async () => {
      renderComponent();

      // Initial state
      expect(screen.{{initialQuery}}).{{initialMatcher}}();

      // Trigger state change
      await user.{{action}}(screen.{{triggerQuery}});

      // Final state
      await waitFor(() => {
        expect(screen.{{finalQuery}}).{{finalMatcher}}();
      });
    });
    {{/each}}

    it('should toggle visibility on click', async () => {
      renderComponent();

      // Initially visible
      expect(screen.getByTestId('content')).toBeVisible();

      // Click toggle
      await user.click(screen.getByRole('button', { name: /toggle/i }));

      // Should be hidden
      await waitFor(() => {
        expect(screen.queryByTestId('content')).not.toBeInTheDocument();
      });

      // Click again
      await user.click(screen.getByRole('button', { name: /toggle/i }));

      // Should be visible again
      await waitFor(() => {
        expect(screen.getByTestId('content')).toBeVisible();
      });
    });

    it('should update counter on increment', async () => {
      renderComponent({ initialCount: 0 });

      expect(screen.getByText('Count: 0')).toBeInTheDocument();

      await user.click(screen.getByRole('button', { name: /increment/i }));

      expect(screen.getByText('Count: 1')).toBeInTheDocument();
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // ACCESSIBILITY TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('Accessibility', () => {
    it('should have no accessibility violations', async () => {
      const { container } = renderComponent();
      // Note: Requires @axe-core/react or jest-axe
      // const results = await axe(container);
      // expect(results).toHaveNoViolations();
      expect(container).toBeInTheDocument();
    });

    it('should be keyboard navigable', async () => {
      renderComponent();

      // Tab through interactive elements
      {{#each keyboardElements}}
      await user.tab();
      expect(screen.{{queryMethod}}('{{selector}}')).toHaveFocus();
      {{/each}}
    });

    it('should have proper ARIA attributes', () => {
      renderComponent();

      {{#each ariaAssertions}}
      expect(screen.{{queryMethod}}('{{selector}}'))
        .toHaveAttribute('{{attribute}}', '{{value}}');
      {{/each}}
    });

    it('should announce dynamic content changes', async () => {
      renderComponent();

      // Trigger content change
      await user.click(screen.getByRole('button', { name: /load/i }));

      // Check aria-live region
      await waitFor(() => {
        const liveRegion = screen.getByRole('status');
        expect(liveRegion).toHaveTextContent(/loaded/i);
      });
    });

    it('should have visible focus indicators', async () => {
      renderComponent();

      const button = screen.getByRole('button');
      await user.tab();

      expect(button).toHaveFocus();
      // Visual check would be done manually or with visual regression tests
    });

    it('should support screen readers', () => {
      renderComponent();

      // Check for proper labels
      expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();
      expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // ERROR STATE TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('Error States', () => {
    it('should display error message on failure', async () => {
      {{#if mockError}}
      {{mockError}}
      {{/if}}

      renderComponent({ error: 'Something went wrong' });

      await waitFor(() => {
        expect(screen.getByRole('alert')).toBeInTheDocument();
        expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
      });
    });

    it('should handle loading state', () => {
      renderComponent({ isLoading: true });

      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
      // Or: expect(screen.getByRole('progressbar')).toBeInTheDocument();
    });

    it('should handle empty state', () => {
      renderComponent({ data: [] });

      expect(screen.getByText(/no {{items}} found/i)).toBeInTheDocument();
    });

    it('should show validation errors', async () => {
      renderComponent();

      // Submit without filling required fields
      await user.click(screen.getByRole('button', { name: /submit/i }));

      // Check for validation errors
      await waitFor(() => {
        expect(screen.getByText(/required/i)).toBeInTheDocument();
      });
    });

    it('should clear error on retry', async () => {
      renderComponent({ error: 'Network error' });

      expect(screen.getByRole('alert')).toBeInTheDocument();

      // Click retry button
      await user.click(screen.getByRole('button', { name: /retry/i }));

      await waitFor(() => {
        expect(screen.queryByRole('alert')).not.toBeInTheDocument();
      });
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // RESPONSIVE TESTS
  // ═══════════════════════════════════════════════════════════════

  describe('Responsive Behavior', () => {
    it('should render mobile layout on small screens', () => {
      // Mock window.matchMedia for mobile
      window.matchMedia = jest.fn().mockImplementation(query => ({
        matches: query === '(max-width: 768px)',
        media: query,
        onchange: null,
        addListener: jest.fn(),
        removeListener: jest.fn(),
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
      }));

      renderComponent();

      expect(screen.getByTestId('mobile-menu')).toBeInTheDocument();
    });

    it('should render desktop layout on large screens', () => {
      // Mock window.matchMedia for desktop
      window.matchMedia = jest.fn().mockImplementation(query => ({
        matches: query === '(min-width: 1024px)',
        media: query,
        onchange: null,
        addListener: jest.fn(),
        removeListener: jest.fn(),
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        dispatchEvent: jest.fn(),
      }));

      renderComponent();

      expect(screen.getByTestId('desktop-nav')).toBeInTheDocument();
    });
  });

  // ═══════════════════════════════════════════════════════════════
  // SNAPSHOT TESTS (Optional)
  // ═══════════════════════════════════════════════════════════════

  describe('Snapshots', () => {
    it('should match snapshot with default props', () => {
      const { container } = renderComponent();
      expect(container).toMatchSnapshot();
    });

    {{#each snapshotVariants}}
    it('should match snapshot with {{variant}}', () => {
      const { container } = renderComponent({{props}});
      expect(container).toMatchSnapshot();
    });
    {{/each}}
  });
});
