---
name: rust-diesel-patterns
description: Diesel ORM patterns for Rust
applies_to: rust
---

# Diesel ORM Patterns

## Overview

Diesel is a safe, extensible ORM and Query Builder for Rust.
It provides compile-time guarantees about query correctness.

## Schema Definition

```rust
// src/schema.rs (auto-generated by diesel_cli)
diesel::table! {
    use diesel::sql_types::*;
    use crate::domain::product::ProductStatusMapping;

    products (id) {
        id -> Uuid,
        name -> Varchar,
        slug -> Varchar,
        description -> Nullable<Text>,
        price -> Numeric,
        compare_price -> Nullable<Numeric>,
        status -> ProductStatusMapping,
        category_id -> Uuid,
        owner_id -> Uuid,
        stock_quantity -> Int4,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        deleted_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    categories (id) {
        id -> Uuid,
        name -> Varchar,
        slug -> Varchar,
        parent_id -> Nullable<Uuid>,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    users (id) {
        id -> Uuid,
        email -> Varchar,
        password_hash -> Varchar,
        name -> Varchar,
        role -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::joinable!(products -> categories (category_id));
diesel::joinable!(products -> users (owner_id));

diesel::allow_tables_to_appear_in_same_query!(
    products,
    categories,
    users,
);
```

## Model Definition

```rust
// src/domain/product/entity.rs
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::schema::products;

/// Queryable model - maps to database rows
#[derive(Debug, Clone, Queryable, Selectable, Serialize)]
#[diesel(table_name = products)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Product {
    pub id: Uuid,
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
    pub price: Decimal,
    pub compare_price: Option<Decimal>,
    pub status: ProductStatus,
    pub category_id: Uuid,
    pub owner_id: Uuid,
    pub stock_quantity: i32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub deleted_at: Option<DateTime<Utc>>,
}

/// Insertable model - for creating new records
#[derive(Debug, Insertable)]
#[diesel(table_name = products)]
pub struct NewProduct {
    pub id: Uuid,
    pub name: String,
    pub slug: String,
    pub description: Option<String>,
    pub price: Decimal,
    pub compare_price: Option<Decimal>,
    pub status: ProductStatus,
    pub category_id: Uuid,
    pub owner_id: Uuid,
    pub stock_quantity: i32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Changeset model - for updates
#[derive(Debug, AsChangeset)]
#[diesel(table_name = products)]
pub struct ProductChangeset {
    pub name: Option<String>,
    pub slug: Option<String>,
    pub description: Option<Option<String>>,
    pub price: Option<Decimal>,
    pub compare_price: Option<Option<Decimal>>,
    pub status: Option<ProductStatus>,
    pub category_id: Option<Uuid>,
    pub stock_quantity: Option<i32>,
    pub updated_at: DateTime<Utc>,
}

/// Custom enum type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, diesel_derive_enum::DbEnum)]
#[ExistingTypePath = "crate::schema::sql_types::ProductStatus"]
pub enum ProductStatus {
    Draft,
    Active,
    Inactive,
    Archived,
}
```

## Connection Pool

```rust
// src/infrastructure/database.rs
use diesel::pg::PgConnection;
use diesel::r2d2::{self, ConnectionManager, Pool, PooledConnection};
use std::time::Duration;

use crate::config::DatabaseConfig;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;
pub type DbConnection = PooledConnection<ConnectionManager<PgConnection>>;

pub struct Database;

impl Database {
    pub fn create_pool(config: &DatabaseConfig) -> DbPool {
        let manager = ConnectionManager::<PgConnection>::new(&config.url);

        Pool::builder()
            .max_size(config.max_connections)
            .min_idle(Some(config.min_connections.unwrap_or(1)))
            .connection_timeout(Duration::from_secs(3))
            .idle_timeout(Some(Duration::from_secs(600)))
            .max_lifetime(Some(Duration::from_secs(1800)))
            .build(manager)
            .expect("Failed to create pool")
    }

    pub fn get_connection(pool: &DbPool) -> Result<DbConnection, r2d2::Error> {
        pool.get()
    }
}
```

## Repository Implementation

```rust
// src/infrastructure/repositories/product_repository.rs
use diesel::prelude::*;
use uuid::Uuid;

use crate::{
    domain::product::{
        entity::{NewProduct, Product, ProductChangeset, ProductStatus},
        repository::{ProductFilter, ProductRepository},
    },
    error::RepositoryError,
    infrastructure::database::DbPool,
    schema::products,
};

pub struct DieselProductRepository {
    pool: DbPool,
}

impl DieselProductRepository {
    pub fn new(pool: DbPool) -> Self {
        Self { pool }
    }
}

impl ProductRepository for DieselProductRepository {
    fn create(&self, product: &NewProduct) -> Result<Product, RepositoryError> {
        let mut conn = self.pool.get()?;

        let created = diesel::insert_into(products::table)
            .values(product)
            .returning(Product::as_returning())
            .get_result(&mut conn)?;

        Ok(created)
    }

    fn get_by_id(&self, id: Uuid) -> Result<Option<Product>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let product = products::table
            .filter(products::id.eq(id))
            .filter(products::deleted_at.is_null())
            .select(Product::as_select())
            .first(&mut conn)
            .optional()?;

        Ok(product)
    }

    fn get_by_slug(&self, slug: &str) -> Result<Option<Product>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let product = products::table
            .filter(products::slug.eq(slug))
            .filter(products::deleted_at.is_null())
            .select(Product::as_select())
            .first(&mut conn)
            .optional()?;

        Ok(product)
    }

    fn update(&self, id: Uuid, changeset: ProductChangeset) -> Result<Product, RepositoryError> {
        let mut conn = self.pool.get()?;

        let updated = diesel::update(products::table.filter(products::id.eq(id)))
            .set(&changeset)
            .returning(Product::as_returning())
            .get_result(&mut conn)?;

        Ok(updated)
    }

    fn soft_delete(&self, id: Uuid) -> Result<(), RepositoryError> {
        let mut conn = self.pool.get()?;

        diesel::update(products::table.filter(products::id.eq(id)))
            .set(products::deleted_at.eq(Some(chrono::Utc::now())))
            .execute(&mut conn)?;

        Ok(())
    }

    fn list(
        &self,
        filter: &ProductFilter,
        offset: i64,
        limit: i64,
    ) -> Result<(Vec<Product>, i64), RepositoryError> {
        let mut conn = self.pool.get()?;

        // Build base query
        let mut query = products::table
            .filter(products::deleted_at.is_null())
            .into_boxed();

        // Apply filters
        if let Some(ref search) = filter.search {
            query = query.filter(
                products::name.ilike(format!("%{}%", search))
                    .or(products::description.ilike(format!("%{}%", search)))
            );
        }

        if let Some(status) = filter.status {
            query = query.filter(products::status.eq(status));
        }

        if let Some(category_id) = filter.category_id {
            query = query.filter(products::category_id.eq(category_id));
        }

        if let Some(min_price) = filter.min_price {
            query = query.filter(products::price.ge(min_price));
        }

        if let Some(max_price) = filter.max_price {
            query = query.filter(products::price.le(max_price));
        }

        // Count total
        let count_query = products::table
            .filter(products::deleted_at.is_null())
            .into_boxed();
        // Apply same filters...

        let total: i64 = count_query.count().get_result(&mut conn)?;

        // Fetch items with pagination
        let items = query
            .order(products::created_at.desc())
            .offset(offset)
            .limit(limit)
            .select(Product::as_select())
            .load(&mut conn)?;

        Ok((items, total))
    }
}
```

## Associations

```rust
// src/domain/product/entity.rs
use crate::domain::category::Category;
use crate::domain::user::User;
use crate::schema::{products, categories, users};

#[derive(Debug, Queryable, Selectable, Identifiable, Associations)]
#[diesel(belongs_to(Category))]
#[diesel(belongs_to(User, foreign_key = owner_id))]
#[diesel(table_name = products)]
pub struct Product {
    // fields...
}

// Loading with associations
impl DieselProductRepository {
    pub fn get_with_category(&self, id: Uuid) -> Result<Option<(Product, Category)>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let result = products::table
            .inner_join(categories::table)
            .filter(products::id.eq(id))
            .select((Product::as_select(), Category::as_select()))
            .first(&mut conn)
            .optional()?;

        Ok(result)
    }

    pub fn get_products_by_category(&self, category_id: Uuid) -> Result<Vec<Product>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let category = categories::table
            .filter(categories::id.eq(category_id))
            .first::<Category>(&mut conn)?;

        let products = Product::belonging_to(&category)
            .select(Product::as_select())
            .load(&mut conn)?;

        Ok(products)
    }
}
```

## Transactions

```rust
impl DieselProductRepository {
    pub fn create_with_inventory(
        &self,
        product: &NewProduct,
        initial_stock: i32,
    ) -> Result<Product, RepositoryError> {
        let mut conn = self.pool.get()?;

        conn.transaction(|conn| {
            // Create product
            let created = diesel::insert_into(products::table)
                .values(product)
                .returning(Product::as_returning())
                .get_result(conn)?;

            // Create inventory record
            diesel::insert_into(inventory::table)
                .values(&NewInventory {
                    product_id: created.id,
                    quantity: initial_stock,
                    warehouse_id: DEFAULT_WAREHOUSE,
                })
                .execute(conn)?;

            Ok(created)
        })
    }
}
```

## Batch Operations

```rust
impl DieselProductRepository {
    pub fn batch_update_status(
        &self,
        ids: &[Uuid],
        status: ProductStatus,
    ) -> Result<usize, RepositoryError> {
        let mut conn = self.pool.get()?;

        let count = diesel::update(products::table)
            .filter(products::id.eq_any(ids))
            .set((
                products::status.eq(status),
                products::updated_at.eq(chrono::Utc::now()),
            ))
            .execute(&mut conn)?;

        Ok(count)
    }

    pub fn batch_insert(&self, products: &[NewProduct]) -> Result<Vec<Product>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let created = diesel::insert_into(products::table)
            .values(products)
            .returning(Product::as_returning())
            .get_results(&mut conn)?;

        Ok(created)
    }
}
```

## Custom SQL

```rust
use diesel::sql_query;
use diesel::sql_types::{Uuid as SqlUuid, Int4, Numeric};

#[derive(Debug, QueryableByName)]
pub struct ProductStats {
    #[diesel(sql_type = SqlUuid)]
    pub category_id: Uuid,
    #[diesel(sql_type = Int4)]
    pub product_count: i32,
    #[diesel(sql_type = Numeric)]
    pub avg_price: Decimal,
}

impl DieselProductRepository {
    pub fn get_category_stats(&self) -> Result<Vec<ProductStats>, RepositoryError> {
        let mut conn = self.pool.get()?;

        let stats = sql_query(
            r#"
            SELECT
                category_id,
                COUNT(*)::int4 as product_count,
                AVG(price) as avg_price
            FROM products
            WHERE deleted_at IS NULL
            GROUP BY category_id
            "#
        )
        .load(&mut conn)?;

        Ok(stats)
    }
}
```

## Migrations

```sql
-- migrations/2024-01-01-000001_create_products/up.sql
CREATE TYPE product_status AS ENUM ('draft', 'active', 'inactive', 'archived');

CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    price NUMERIC(10, 2) NOT NULL,
    compare_price NUMERIC(10, 2),
    status product_status NOT NULL DEFAULT 'draft',
    category_id UUID NOT NULL REFERENCES categories(id),
    owner_id UUID NOT NULL REFERENCES users(id),
    stock_quantity INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    CONSTRAINT price_positive CHECK (price >= 0)
);

CREATE INDEX idx_products_slug ON products(slug);
CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_status ON products(status) WHERE deleted_at IS NULL;

-- migrations/2024-01-01-000001_create_products/down.sql
DROP TABLE IF EXISTS products;
DROP TYPE IF EXISTS product_status;
```

## Best Practices

1. **Use derive macros**: Queryable, Insertable, AsChangeset for type safety
2. **Separate models**: Use different structs for query, insert, update
3. **Boxed queries**: For dynamic query building
4. **Associations**: Use Diesel's association macros for joins
5. **Transactions**: Use `.transaction()` for atomicity
6. **Connection pooling**: Use r2d2 for connection management
7. **Migrations**: Use diesel_cli for schema management
