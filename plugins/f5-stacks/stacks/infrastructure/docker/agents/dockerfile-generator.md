# Dockerfile Generator Agent

## Purpose
Generates optimized, production-ready Dockerfiles for any language/framework with multi-stage builds, security best practices, and proper caching.

## Activation
- User requests: "create dockerfile", "dockerize this app", "generate docker config"
- Project contains: package.json, requirements.txt, go.mod, pom.xml, Cargo.toml
- Commands: `/docker:generate`, `/docker:dockerfile`

## Capabilities

### Language Detection
Automatically detects project language and framework:
- **Node.js**: package.json, yarn.lock, pnpm-lock.yaml
- **Python**: requirements.txt, Pipfile, pyproject.toml, setup.py
- **Go**: go.mod, go.sum
- **Java**: pom.xml, build.gradle
- **Rust**: Cargo.toml
- **.NET**: *.csproj, *.sln

### Multi-Stage Build Generation
Creates optimized multi-stage Dockerfiles:
1. **Dependencies stage**: Install and cache dependencies
2. **Builder stage**: Compile/build application
3. **Development stage**: Hot reload setup
4. **Production stage**: Minimal runtime image

### Security Best Practices
- Non-root user creation
- Minimal base images (alpine, slim, distroless)
- No secrets in image
- Health checks
- Proper signal handling

## Input Requirements

```yaml
required:
  - project_type: "node|python|go|java|rust|dotnet"

optional:
  - node_version: "20"
  - python_version: "3.12"
  - go_version: "1.22"
  - java_version: "21"
  - base_image: "alpine|slim|distroless"
  - port: 3000
  - has_healthcheck: true
  - include_dev_stage: true
```

## Output Format

### Generated Dockerfile Structure

```dockerfile
# =============================================================================
# Multi-Stage Dockerfile for {{project_type}}
# Generated by F5 Framework
# =============================================================================

# Build arguments
ARG {{LANG}}_VERSION={{version}}

# Stage 1: Dependencies
FROM {{base_image}} AS deps
# ... dependency installation

# Stage 2: Builder
FROM {{base_image}} AS builder
# ... build process

# Stage 3: Development (optional)
FROM {{base_image}} AS development
# ... dev setup with hot reload

# Stage 4: Production
FROM {{base_image}} AS production
# ... minimal production image
```

### Generated .dockerignore

```dockerignore
# Generated .dockerignore
.git
node_modules
__pycache__
.env*
*.log
Dockerfile*
docker-compose*
README.md
docs/
test/
coverage/
```

## Generation Rules

### Node.js Projects
```yaml
detect_package_manager:
  - npm: package-lock.json
  - yarn: yarn.lock
  - pnpm: pnpm-lock.yaml

install_command:
  npm: "npm ci --only=production"
  yarn: "yarn --frozen-lockfile --production"
  pnpm: "pnpm install --frozen-lockfile --prod"

base_images:
  default: "node:20-alpine"
  with_native_deps: "node:20-slim"
```

### Python Projects
```yaml
detect_dependency_manager:
  - pip: requirements.txt
  - pipenv: Pipfile
  - poetry: pyproject.toml

virtual_env: "/opt/venv"

base_images:
  default: "python:3.12-slim"
  with_c_extensions: "python:3.12-bookworm"
```

### Go Projects
```yaml
build_flags: >
  CGO_ENABLED=0 GOOS=linux GOARCH=amd64
  -ldflags='-w -s -extldflags "-static"'

base_images:
  build: "golang:1.22-alpine"
  runtime: "gcr.io/distroless/static-debian12"
```

### Java Projects
```yaml
detect_build_tool:
  - maven: pom.xml
  - gradle: build.gradle

layer_extraction: true  # Use Spring Boot layertools

base_images:
  build: "eclipse-temurin:21-jdk-alpine"
  runtime: "eclipse-temurin:21-jre-alpine"

jvm_options: >
  -XX:+UseContainerSupport
  -XX:MaxRAMPercentage=75.0
```

## Example Generation

### Input
```yaml
project_type: node
framework: nestjs
port: 3000
include_dev_stage: true
has_healthcheck: true
```

### Output
```dockerfile
# =============================================================================
# Multi-Stage Dockerfile for NestJS Application
# =============================================================================
ARG NODE_VERSION=20

# Stage 1: Dependencies
FROM node:${NODE_VERSION}-alpine AS deps
WORKDIR /app
RUN apk add --no-cache libc6-compat
COPY package.json package-lock.json* ./
RUN npm ci && npm cache clean --force

# Stage 2: Builder
FROM node:${NODE_VERSION}-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build
RUN npm prune --production

# Stage 3: Development
FROM node:${NODE_VERSION}-alpine AS development
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
EXPOSE 3000
CMD ["npm", "run", "start:dev"]

# Stage 4: Production
FROM node:${NODE_VERSION}-alpine AS production
WORKDIR /app
ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 appuser

COPY --from=builder --chown=appuser:nodejs /app/dist ./dist
COPY --from=builder --chown=appuser:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=appuser:nodejs /app/package.json ./

USER appuser
EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

CMD ["node", "dist/main.js"]
```

## Validation Checklist

Before finalizing Dockerfile:
- [ ] Uses specific base image version (not :latest)
- [ ] Multi-stage build separates build and runtime
- [ ] Non-root user created and used
- [ ] Health check included
- [ ] .dockerignore generated
- [ ] Dependencies cached before source code
- [ ] Cleanup in same RUN layer
- [ ] No secrets embedded

## Related Skills
- dockerfile/multi-stage-builds
- dockerfile/best-practices
- dockerfile/layer-optimization
- security/image-security
